<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Http\Requests\UserRequest;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Symfony\Component\HttpFoundation\Response;

class UserController extends Controller
{
    public function __construct()
    {
        $this->middleware('auth:sanctum'); //* Defend against unauth'd users 
        //* Role check should forbid the rest
        //? Specifically for resource controllers, but API controllers work too
        $this->authorizeResource(User::class, 'user'); //? Link policies
        //? What about create and edit routes? (GET version of Store and Update routes [which are POST/PUT])
        //? Works as expected (when using Sanctum anyways) - returns 403 Forbidden
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index(Request $request)
    {
        $user = $request->user();

        //* Policy will actually catch send the forbidden response BUT to be explicit
        //* 400 Unauthorized an option but Forbidden denotes user ID'd & not allowed
        return ($user->role > 0) ? User::paginate(15) : response(null, Response::HTTP_FORBIDDEN); //* Admins only!
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(UserRequest $request)
    {
        $data = $request->validated();

        $newUser = new User([
            'first_name' => $data['first_name'],
            'surname' => $data['surname'],
            'email' => $data['email'],
            'password' => Hash::make($data['password']),
            'account_type' => $data['account_type'],
            'role' => 0, //* No one but dev sets this
        ]);

        return $newUser->save() ? response($newUser, Response::HTTP_CREATED) : response(null, Response::HTTP_NOT_FOUND);
    }

    /**
     * Display the specified resource.
     *
     * @param  \App\User  $user
     * @return \Illuminate\Http\Response
     */
    //? ROUTE Model Binding! Inject more than just an $id, laravel will query & grab the matching Model!
    //? How? All Resource controllers generated by "php artisan make:controller UserController" make the following route
    //? SHOW: '/users/{user}' so if show method type hints a param with matching variable name, then laravel auto injects!
    //? SHOW: '/users/{user}' => show(User $user) SO if $user became User $usr then it wouldn't auto inject
    //? If no User with a matching ID exists, then show(User $user) will not fire & Laravel will send a 404 response
    //? It's also possible to use a different column to find a matching model in the DB (so besides the primary key: id)
    //? NOTE: For this project, we used --api with the above command for just the needed routes (so no create or edit view route, just POST versions)
    public function show(User $user)
    {
        // $authUser = Auth::user(); //? Alternatively Auth::id() or Auth::check()
        return response()->json($user, Response::HTTP_OK);
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \App\User  $user
     * @return \Illuminate\Http\Response
     */
    public function update(UserRequest $request, User $user)
    {
        $data = $request->validated();
        $userDataArr = $user->toArray();
        //* Goal: Only update changed values so array_diff should only provide us values that are diff'd
        //* Meanwhile front end populates fields, user changes what they want, confirms via pw, form sends it all back, we pick & choose here
        $onlyUpdateSome = array_diff($data, $userDataArr);

        //* Either use newly updated validated data OR data already present in the DB (basically if nothing changed so it didn't get diff'd)
        $finalData = [
            'first_name' => $onlyUpdateSome['first_name'] ?? $userDataArr['first_name'],
            'surname' => $onlyUpdateSome['surname'] ?? $userDataArr['surname'],
            'email' => $onlyUpdateSome['email'] ?? $userDataArr['email'],
            'password' => Hash::make($onlyUpdateSome['password'] ?? $userDataArr['password']),
            'account_type' => $userDataArr['account_type'], //* Effectively unable to be changed - maybe future admin route to change it and handle all the changes
            'role' => 0, //* Always got to be sure no one is trying to be sneaky
        ];

        //? Fill, create, & update aren't necessarily protected from mass assignment so handcrafting like above is always good practice
        //? BUT with a $fillable attribute on the model, mass assignment exceptions will get thrown if someone sneaky comes around
        return $user->update($finalData) ? response($user, Response::HTTP_NO_CONTENT) : response(null, Response::HTTP_BAD_REQUEST);
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  \App\User  $user
     * @return \Illuminate\Http\Response
     */
    public function destroy(User $user)
    {
        //* Since laravel retrieved this $user, we're good to delete since it made it past policy
        $user->delete(); //* BUT don't confuse with $request->user
        return response(null, Response::HTTP_NO_CONTENT);
    }
}
